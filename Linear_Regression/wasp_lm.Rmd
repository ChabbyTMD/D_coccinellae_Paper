---
title: "Parasitoid heritability"
output:
  html_document:
    df_print: paged
---

# libraries

Import libraries and the data:

```{r import.data}
# setwd("/set/path/here")
library(tidyverse)
library(readxl)

wasp <- read.csv2("DATA/morph_data_bk.csv", sep = ",")
wasp$p.host.sl <- as.factor(wasp$p.host.sl)

```

First, confirm that all possible combinations of host parent and offspring host species exist, and are in roughly equal numbers:

```{r check.balance.parent.offspring}

xtabs(~ p.host.sl + o.host.sl, data = wasp)

```

Unbalanced designs have lower statistical power, and if both offspring and parent hosts are used as predictors in a model their effects won't be independent of one another.

Comparing the parent morphological variables by parent host species - wing length is presented as an example, but the same models can be run for each variable.

```{r parent.wl.by.host.sl}

lm(p.wl ~ p.host.sl, data = wasp) -> parent.wl.host.sl.lm
anova(parent.wl.host.sl.lm)

```

The small/large version of the parent host variable is not statistically significant.

A model using the host species is significant:

```{r parent.wl.by.host}

lm(p.wl ~ p.host, data = wasp) -> parent.wl.host.lm
anova(parent.wl.host.lm)

```

Post-hoc procedures can be done using the emmeans library. To obtain Tukey comparisons:

```{r parent.wl.by.host.tukey}

library(emmeans)
emmeans(parent.wl.host.lm, tukey ~ p.host)

```

Wing lengths differ between C. maculata and H. convergens hosts. These are the two species grouped into "small", which explains why the small/large grouping is not significant.

The emmeans package makes it simple to graphically represent the model, but be aware that the error bars are based on the MSerror for the model - since the standard errors are not estimated separately from the data in each group they will differ from ones generated by summarizing the data.

```{r plot.wl.host.lm.model}

emmip(parent.wl.host.lm, ~p.host) + geom_errorbar(aes(ymin = yvar - SE, ymax = yvar + SE), width=0.1)

```

A parent/offspring regression can be used to estimate heritability. Offspring Wing length is used as the response variable, and parent wing length is used as a predictor. Graphically:

```{r wl.parent.offspring.graph}

library(ggplot2)
ggplot(wasp, aes(x = p.wl, y = o.wl)) + geom_point() + geom_smooth(method = "lm", se = F)

```


The simple linear regression model that matches this graph is:

```{r wl.parent.offspring.lm}

lm(o.wl ~ p.wl, data = wasp) -> wl.p.o.lm
anova(wl.p.o.lm)
summary(wl.p.o.lm)

```
The model is not statistically significant, but the slope estimate of 0.174 is the heritability estimate.

Accounting for the host species that the parent was reared on is done by including p.host as a predictor along with p.wl. If we include it as an additive term then the model uses parallel lines with the same slope but different y-intercepts. The model is:

```{r wl.parent.offspring.phost.lm}

lm(o.wl ~p.wl + p.host, data = wasp) -> wl.p.o.phost.lm
anova(wl.p.o.phost.lm)
summary(wl.p.o.phost.lm)

```

Note that R's built-in anova() command only provides sequential, Type I sums of squares tests. When more than one predictor is used, and they are correlated to some degree, the Type I tests assign all of the shared variation to the first predictor, and the second accounts for variation in the response that has not already been accounted for by the first. To only use the variation explained by each predictor independent of the other Type II SS tests are needed, and they are provided by the car package.

```{r typeII.ss.anova}

library(car)
Anova(wl.p.o.phost.lm)

```

With Type II SS each predictor variable is only given the variation in the response that it is able to explain independent of the other predictor. The coefficients are not affected by this choice, so the summary() output is pertinent here as well - the coefficients are partial coefficients, meaning that they measure the effects independent of the other predictors in the model.


We can visualize this model with emmip:

```{r visualize.parent.offspring.phost.lm}

# emmip(wl.p.o.phost.lm, p.host ~ p.wl, cov.reduce = F) + geom_point(data=wasp, aes(x = p.wl, y = o.wl, color = p.host)) + labs(y = "Offspring wing length", x = "Parent wing length")

```

This graph represents the structure of the model, but it may not represent the actual patterns of response well. To allow each p.host to have a line with a different slope we would need to add an interaction between p.host and p.wl.

```{r wl.p.o.int.lm}

lm(o.wl ~ p.wl * p.host, data = wasp) ->  wl.p.o.phost.int.lm
anova(wl.p.o.phost.int.lm)
summary(wl.p.o.phost.int.lm)


```

This model can be visualized with:

```{r wl.p.o.int.graph}

# emmip(wl.p.o.phost.int.lm, p.host ~ p.wl, cov.reduce = F) + geom_point(data=wasp, aes(x = p.wl, y = o.wl, color = p.host)) + labs(y = "Offspring wing length", x = "Parent wing length")

```


Including both the parent host and the offspring host:

```{r wl.phost.ohost.lm}

lm(o.wl ~ p.host + o.host, data = wasp) -> wl.phost.ohost.lm
anova(wl.phost.ohost.lm)
summary(wl.phost.ohost.lm)

```


```{r wl.phost.ohost.int.lm}

lm(o.wl ~ p.host * o.host, data = wasp) -> wl.phost.ohost.int.lm
anova(wl.phost.ohost.int.lm)
summary(wl.phost.ohost.int.lm)

```


```{r wl.phost.ohost.int.p.wl.lm}

lm(o.wl ~ p.host * o.host + p.wl, data = wasp) -> wl.phost.ohost.p.wl.lm
anova(wl.phost.ohost.p.wl.lm)
summary(wl.phost.ohost.p.wl.lm)

```